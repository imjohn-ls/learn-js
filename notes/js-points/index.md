#this,call,bind,apply
_ _ _
 >this是一个指向函数执行环境的指针，this永远指向最后调用它的对象，执行时才能获取值，定义时无法确认它的值。  
 >call,apply,bind第一个参数都是this指向的对象，call和apply如果第一个参数指向null或undefined,this指向window对象--*-call和apply改变上下文中的this，并且是立即执行，bind方法可以让对应函数想什么时候调用就什么时候调用。_  
>call和apply第二个参数格式不同，call逗号隔开，apply数组形式  bind参数和call一样，bind返回值是一个方法，传的参数会预先传给返回的方法，调用的时候不用再传参数。
***
#js模块化，Commonjs，Amd异步模块定义，cmd，es6
_ _ _
 >开始js是没有模块化的说法，js代码就一个一个从上到下执行模块化的优点，方便开发维护，解耦，只需要依赖需要的模块，避免全局污染.Commonjs,AMD,CMD,es6 都是js模块化的规范，只不过es6 是js自己的规范
 >Commonjs 是应用于服务端的javaScript，一个js文件就是一个模块，模块中的变量不对外暴露，不支持异步。nodejs 遵循commonjs规范，同步加载模块
 >一个作为公共依赖的模块，同步一次加载出来更好，模块的个数往往是有限的，而且Nodejs在require的时候会走动缓存已加载过的模块，访问的是本地文件，产生的IO开销几乎可以忽略  
   基本用法      
   require 引用模块   
   exports 导出模块   
   module 模块标识    
>Amd适用浏览器，第一个参数是要加载的模块数组，即使只加载一个模块，也要使用数组形式。第二个参数是加载成功之后的回调函数。依赖前置，requirejs遵循AMD规范
>cmd适用浏览器端，一个模块就是一个文件，就近依赖，即用即返,同步模块
>es6: es6中一个文件默认为一个模块，通过export向外暴露，import输入其他模块提供的功能
#exports和module.exports
***
>在node执行一个文件时，会给这个文件内生成一个exports和module对象，而module又有一个exports属性
`exports = module.exports = {};`
>exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。只通过 exports 参数来提供接口，有时无法满足开发者的所有需求。 比如当模块的接口是某个类的实例时，需要通过 module.exports

#vue生命周期
***
>beforecreate，创建，初始化实例    
  create：ajax请求，data数据方法，watch/event事件回调    
  beforeMOUNT:执行render    
  mount：el挂载执行，节点获取和操作    
  beforeupdate:数据更新，不进行dom渲染，可进行状态处理    
  update：数据更新 dom重新渲染    
  beforedestory：实例销毁之前调用    
  destory：实例销毁
#面向对象三个特性：封装 继承 多态
***
>一个类只能继承一个父类，但是可以实现多个接口在Java中只允许继承一个类，但可实现多个接口。通过实现多个接口方式满足多继承的设计需求实现接口时接口中原有的抽象方法在实现类中必须实现。默认方法可以根据需要有选择实现（覆盖）。静态方法不需要实现，实现类中不能拥有接口中的静态方法。
#进程&线程
***
>一个进程就是一个执行中的程序，每一个进程都有自己独立的一块内存和一组系统资源，线程是完成某一特定功能的代码是程序中单个顺序控制的流程，同类的多个线程共享一块内存空间和一组系统资，系统在各个线程间切换开支要比进程小，一个进程包含多个线程
#TCP/IP
***
>网络通信会用到协议，其中TCP/IP协议是非常重要的。TCP/IP协议是由IP和TCP两个协议构成的，IP（Internet Protocol）协议是一种低级的路由协议，它将数据拆分成许多小的数据包中，并通过网络将它们发送到某一特定地址，但无法保证都所有包都抵达目的地，也不能保证包的顺序。由于IP协议传输数据的不安全性，网络通信时还需要TCP协议，传输控制协议（Transmission ControlProtocol，TCP）是一种高层次的协议，面向连接的可靠数据传输协议，如果有些数据包没有收到会重发，并对数据包内容准确性检查并保证数据包顺序，所以该协议保证数据包能够安全地按照发送时顺序送达目的地。UDP（用户数据报协议）就像日常生活中的邮件投递，是不能保证可靠地寄到目的地。UDP是无连接的，对系统资源的要求较少，UDP可能丢包不保证数据顺序。但是对于网络游戏和在线视频等要求传输快、实时性高、质量可稍差一点的数据传输，UDP还是非常不错的。
#HTTP
***
>HTTP是Hypertext Transfer Protocol的缩写，即超文本传输协议。HTTP是一个属于应用层的面向对象的协议，其简捷、快速的方式适用于分布式超文本信息的传输。它于1990年提出，经过多年的使用与发展，得到不断完善和扩展。HTTP协议支持C/S网络结构，是无连接协议，即每一次请求时建立连接，服务器处理完客户端的请求后，应答给客户端然后断开连接，不会一直占用网络资源。
#HTTPS
***
>HTTPS是Hypertext Transfer Protocol Secure，即超文本传输安全协议，是超文本传输协议和SSL的组合，用以提供加密通信及对网络服务器身份的鉴定。简单地说，HTTPS是HTTP的升级版，HTTPS与HTTP的区别是：HTTPS使用https://代替http://，HTTPS使用端口443，而HTTP使用端口80来与TCP/IP进行通信。SSL使用40位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。HTTPS和SSL支持使用X.509数字认证，如果需要的话，用户可以确认发送者是谁。整型：Byte 8位  short 16位 int 32位 long 64位 （-2^63---2^63-1）   浮点型： double float 字符: char 布尔： Boolean 引用类型：数组 接口 类接口和抽象类：在抽象类中除了抽象方法之外，也可以定义普通的成员方法和成员变量，而在接口中这是不允许的，接口中只能有方法声明和常量定义（静态成员变量），这是抽象类和接口的本质区别 接口允许多继承不但一个接口可以继承多个父接口，而且实现接口的类也可以同时实现多个接口





